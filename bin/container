#!/bin/bash

function usage {
cat >&2 <<'EOF'
Usage: container COMMAND [NAME..]

Where COMMAND is one of:
  bootstrap     Setup template dir with pacstrap
  create <name> Create container in btrfs subvolume
  delete <name> Delete container and btrfs subvolume
  list          List running containers
  root <name>   Get root shell in named container
  start <name>  Start named container
  stop <name>   Stop named container
  trust <name> <other..> Add name to other machines' authorized_keys
EOF
exit 1
}

CMD=$1
[[ -z $CMD ]] && usage
shift

NAME=$1
[[ -z $NAME ]] && [[ $CMD != bootstrap ]] && [[ $CMD != list ]] && usage
shift

ROOT=$HOME/data
SRC=$HOME/src/comdb2
USER=comdb2
STARTCMD="-q --boot --directory $ROOT/$NAME --network-bridge=br0"
CREATECMD="$STARTCMD --template=$ROOT/template"

function start {
    sudo systemd-nspawn $STARTCMD --bind=$SRC:/home/$USER/comdb2 >/dev/null 2>&1 &
}

function root {
    sudo machinectl -q shell $NAME
}

function list {
    sudo machinectl list
}

function stop {
    sudo machinectl -q poweroff $NAME
}

function setup {
HOST_PUBLIC_KEY=$(<$HOME/.ssh/id_rsa_thinkpad.pub)

read -d '' BASHRC <<'EOF'
PATH=/opt/bb/bin:\\\$PATH
alias installcomdb2=\\\"tar -C /opt/bb --strip-components=3 -x -f comdb2.tar.gz\\\"
EOF

read -d '' STRICT_CHECK <<'EOF'
Host \*
    StrictHostKeyChecking no
EOF

read -d '' INPUTRC <<'EOF'
set editing-mode vi

set keymap vi-command
Control-l: clear-screen

set keymap vi-insert
Control-l: clear-screen
EOF

read -d '' GDBINIT <<'EOF'
set print thread-events off
set height 0
set print pretty on
set confirm off

define whereall
thread apply all where
end

document whereall
Alias for \\\"thread apply all where\\\"
end
EOF

sudo systemd-run --pipe --machine=$NAME /bin/bash > /dev/null <<EOF
/usr/bin/systemctl enable systemd-networkd
/usr/bin/systemctl enable systemd-resolved
/usr/bin/systemctl enable sshd.socket
/usr/bin/hostnamectl set-hostname $NAME
/usr/bin/useradd $USER --create-home --user-group
/usr/bin/mkdir -p /opt/bb
/usr/bin/chown $USER:$USER /opt/bb
/usr/bin/su -c 'ssh-keygen -q -f /home/$USER/.ssh/id_rsa -N ""' $USER
/usr/bin/su -c 'echo "$HOST_PUBLIC_KEY" > /home/$USER/.ssh/authorized_keys' $USER
/usr/bin/su -c 'echo "$STRICT_CHECK" > /home/$USER/.ssh/config' $USER
/usr/bin/su -c 'echo "$BASHRC" >> /home/$USER/.bashrc' $USER
/usr/bin/su -c 'echo "$INPUTRC" >> /home/$USER/.inputrc' $USER
/usr/bin/su -c 'echo "$GDBINIT" >> /home/$USER/.gdbinit' $USER
EOF
}

function create {
    tmux split-window -p 50 -h sudo systemd-nspawn $CREATECMD
    tmux select-pane -t 0
    echo -n "Press a key to run setup"
    read
    setup
    stop
    sleep 1
}

function delete {
    sudo btrfs subvolume delete $ROOT/$NAME
}

function bridge {
    if ! brctl show br0 > /dev/null 2>&1; then
        sudo brctl addbr br0
    fi
    if ! ip link show br0 | grep UP > /dev/null ; then
        sudo ip link set up br0
    fi
}

function bootstrap {
    sudo pacstrap -i -c $ROOT/template base gdb make openssh protobuf-c
}

function make_trust {
    ssh $1 cat .ssh/id_rsa.pub | ssh $2 tee --append .ssh/authorized_keys > /dev/null
}

function trust {
    for M in $*; do
        [[ $M == $NAME ]] && continue
        make_trust $NAME $M
    done
}

case $CMD in
    bootstrap) bootstrap ; exit ;;
    create) bridge; create ; exit ;;
    delete) delete ; exit ;;
    list) list ; exit ;;
    root) root ; exit ;;
    start) bridge; start ; exit ;;
    stop) stop ; exit ;;
    trust) trust $* ; exit ;;
    *) usage ;;
esac
